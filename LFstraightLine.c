#pragma config(Sensor, in1,    AutoPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFrear,              sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl10, clawLimitSensor,     sensorTouch)
#pragma config(Sensor, dgtl11, startButton,         sensorTouch)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           arm2,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "LFstraightLine.c"
AUTHOR: Matthew Walker 

  not a PID controler. Just has 2 "meat" methods that do what
  they say and a test method to test one.
  
*/

#ifndef MAIN_USED
  #define LFSL_IS_MAIN
  #define MAIN_USED
#endif

#include "controlCode.c"
#include "QEstraightLine.c"
#include "QEstop.c"

//float lfslPidVars[] = {1.25,0.05,0.4};
//                     P tweak (anything higher than this will work)
//                          I tweak
//                              D tweak



/*void LfPidLoopContents(int length){
  //static float rightPwrLF = 0;
  //static float leftPwrLF = 0;

  //setRight(rightPwrLF);
  //setLeft(leftPwrLF);
}*/

/**
  every time the loop iterates, the bool at timeOut is checked. if true, exits loop
  the approxlength is best slightly overestimated
*/
void goForwardUntilLine(int approxLength,bool stopThere, bool* timeOut){
  resetWheelQEs();
  while (getLFl()>WHITE_FLOOR && getLFr()>WHITE_FLOOR && ((getWheelQeAverage() + 3*TICKS_CM) < approxLength) && !timeOut){
    QePidLoopContents(approxLength,false);
  }
  if (stopThere){
    normalStop();
  }
}

/**
  see goForwardUntilLine(int approxLength,bool stopThere, bool* timeOut)
  for more info. FARCE is a boolean with the value false that is not 
  changed under normal circumstances.
*/
void goForwardUntilLine(int approxLength,bool stopThere){
  goForwardUntilLine(approxLength,stopThere, FARCE);
}

#ifdef LFSL_IS_MAIN
task main(){
#else
void LFstraightMain(){
#endif

  StartTask(stopper);
  while(vexRT[Btn5D] != 1){//press Btn5D and exit button to end

    //++++++++++++++ == RC/adjusting part == ++++++++++++++

    bool B7UReleased = true;
    bool B7DReleased = true;
    bool B7RReleased = true;
    bool B7LReleased = true;
    bool B8UReleased = true;
    bool B8DReleased = true;

    while(vexRT[Btn6U] != 1){//press Btn6U to get out

      /*if (vexRT[Btn5D] == 0 && vexRT[Btn6D] == 0){
        setMotorsToRC();
        int errorSample = getRawStraightLineError();
        }else{
        if (vexRT[Btn7U] != 0 && B7UReleased){//if down
          lfslPidVars[KP] += 0.01;
          //writeDebugStreamLine("lfslPidVars[KP] = %f", lfslPidVars[KP]);
          B7UReleased = false;
          } else if (vexRT[Btn7U] != 1){
          B7UReleased = true;
        }
        if (vexRT[Btn7D] != 0 && B7DReleased){//if down
          lfslPidVars[KP] -= 0.01;
          //writeDebugStreamLine("lfslPidVars[KP] = %f", lfslPidVars[KP]);
          B7DReleased = false;
          } else if (vexRT[Btn7D] != 1){
          B7DReleased = true;
        }

        if (vexRT[Btn7R] != 0 && B7RReleased){//if down
          lfslPidVars[KD] += 0.01;
          //writeDebugStreamLine("lfslPidVars[KD] = %f", lfslPidVars[KD]);
          B7RReleased = false;
          } else if (vexRT[Btn7R] != 1){
          B7RReleased = true;
        }
        if (vexRT[Btn7L] != 0 && B7LReleased){//if down
          lfslPidVars[KD] -= 0.01;
          //writeDebugStreamLine("lfslPidVars[KD] = %f", lfslPidVars[KD]);
          B7LReleased = false;
          }else if (vexRT[Btn7L] != 1){
          B7LReleased = true;
        }
        if (vexRT[Btn8U] != 0 && B8UReleased){//if down
          lfslPidVars[KI] += 0.01;
          //writeDebugStreamLine("lfslPidVars[KI] = %f", lfslPidVars[KI]);
          B8UReleased = false;
          } else if (vexRT[Btn8U] != 1){
          B8UReleased = true;
        }
        if (vexRT[Btn8D] != 0 && B8DReleased){//if down
          lfslPidVars[KI] -= 0.01;
          //writeDebugStreamLine("lfslPidVars[KI] = %f", lfslPidVars[KI]);
          B8DReleased = false;
          } else if (vexRT[Btn8D] != 1){
          B8DReleased = true;
        }
      }
    }*/

    //++++++++++++++ == PID part == ++++++++++++++

    resetWheelQEs();
    //while(vexRT[Btn6D] != 1){//press Btn6D to get out
      goForwardUntilLine(100,true,stopNow);//stopNow is set by the task "stopper"
    //}
  }
}
