#pragma config(Sensor, in1,    AutoPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFrear,              sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl10, clawLimitSensor,     sensorTouch)
#pragma config(Sensor, dgtl11, startButton,         sensorTouch)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           arm2,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "QEstraightLine.c"
AUTHOR: Matthew Walker 

A PID controller that is designed to make the bot travel
in a straight line, that uses data from the left and right QEs.

Controls:
*/


#ifndef MAIN_USED
  #define QESL_IS_MAIN
  #define MAIN_USED
#endif

#include "controlCode.c"
#include "QEstop.c"

float qesPidVars[] = {1.25,0.05,0.4};
//                     P tweak (anything higher than this will work)
//                          I tweak
//                              D tweak

void QePidLoopContents(int length, bool reverse){

  static float rightPwr = 0;
  static float leftPwr = 0;
  static int integralErr = 0;
  static int change = 0;
  static int oldError = 0;
  static int error = 0;

  error = getRawStraightLineError();
  if (reverse){
    length *= -1;
    error *= -1;
  }
  integralErr += error;
  if (integralErr > 200){
    integralErr = 200;
  }else if (integralErr < -200){
    integralErr = -200;
  }
  change = qesPidVars[KP]*error + qesPidVars[KI]*integralErr + qesPidVars[KD]*(oldError - error);

  rightPwr  = (-change+110);
  leftPwr  = (+change+110);
  /*if (length < (50*TICKS_CM) && (length - getWheelQeAverage())<(30*TICKS_CM)){
     rightPwrQE *=abs(((float)getQEr() - (float)length)/((float)length*2));
     leftPwrQE *=abs(((float)getQel() - (float)length)/((float)length*2));
  }*/
  oldError = error;
  /*while (vexRT[Btn5U] != 0){//hold 5U to pause
    setRight(0);
    setLeft(0);
  }*/
  if(reverse){
    setRight(-rightPwr);
    setLeft(-leftPwr);
  }else{
    setRight(rightPwr);
    setLeft(leftPwr);
  }

  wait1Msec(50);
}

void goForward(int length, bool stopThere){
  resetWheelQEs();
  while (getWheelQeAverage()<length){
    QePidLoopContents(length,false);
  }
  if (stopThere){
    normalStop();
  }
}

void goBackward(int length, bool stopThere){
  resetWheelQEs();
  while (getWheelQeAverage()>(-length)){
    QePidLoopContents(length,true);
  }
  if (stopThere){
    normalStop();
  }
}

void goForwardUntilLimit(int approxLength, bool stopThere){
  resetWheelQEs();
  while (SensorValue[clawLimitSensor]!=1){
    QePidLoopContents(approxLength,false);
  }
    if (stopThere){
    stopBothWheels();
    wait1Msec(500);
    releaseBothWheels();
  }
}

void goForwardCm(int cmF,bool stopThere){
  goForward(cmF*TICKS_CM,stopThere);
}

void goBackwardCm(int cmB,bool stopThere){
  goBackward(cmB*TICKS_CM,stopThere);
}

#ifdef QESL_IS_MAIN
task main(){
#else
void QEstraightMain(){
#endif
  resetTowerQE();
  resetWheelQEs();

  while(vexRT[Btn5D] != 1){//press Btn5D and exit button to end

    //++++++++++++++ == RC/adjusting part == ++++++++++++++

    bool B7UReleased = true;
    bool B7DReleased = true;
    bool B7RReleased = true;
    bool B7LReleased = true;
    bool B8UReleased = true;
    bool B8DReleased = true;

    while(vexRT[Btn6U] != 1){//press Btn6U to get out

      if (vexRT[Btn5D] == 0 && vexRT[Btn6D] == 0){
        setMotorsToRC();
        int errorSample = getRawStraightLineError();
        }else{
        if (vexRT[Btn7U] != 0 && B7UReleased){//if down
          qesPidVars[KP] += 0.01;
          //writeDebugStreamLine("qesPidVars[KP] = %f", qesPidVars[KP]);
          B7UReleased = false;
          } else if (vexRT[Btn7U] != 1){
          B7UReleased = true;
        }
        if (vexRT[Btn7D] != 0 && B7DReleased){//if down
          qesPidVars[KP] -= 0.01;
          //writeDebugStreamLine("qesPidVars[KP] = %f", qesPidVars[KP]);
          B7DReleased = false;
          } else if (vexRT[Btn7D] != 1){
          B7DReleased = true;
        }

        if (vexRT[Btn7R] != 0 && B7RReleased){//if down
          qesPidVars[KD] += 0.01;
          //writeDebugStreamLine("qesPidVars[KD] = %f", qesPidVars[KD]);
          B7RReleased = false;
          } else if (vexRT[Btn7R] != 1){
          B7RReleased = true;
        }
        if (vexRT[Btn7L] != 0 && B7LReleased){//if down
          qesPidVars[KD] -= 0.01;
          writeDebugStreamLine("qesPidVars[KD] = %f", qesPidVars[KD]);
          B7LReleased = false;
          } else if (vexRT[Btn7L] != 1){
          B7LReleased = true;
        }
        if (vexRT[Btn8U] != 0 && B8UReleased){//if down
          qesPidVars[KI] += 0.01;
          //writeDebugStreamLine("qesPidVars[KI] = %f", qesPidVars[KI]);
          B8UReleased = false;
          } else if (vexRT[Btn8U] != 1){
          B8UReleased = true;
        }
        if (vexRT[Btn8D] != 0 && B8DReleased){//if down
          qesPidVars[KI] -= 0.01;
          //writeDebugStreamLine("qesPidVars[KI] = %f", qesPidVars[KI]);
          B8DReleased = false;
          } else if (vexRT[Btn8D] != 1){
          B8DReleased = true;
        }
      }
    }

    //++++++++++++++ == PID part == ++++++++++++++

    resetWheelQEs();
    while(vexRT[Btn6D] != 1){//press Btn6D to get out
      if ((bool)vexRT[Btn7U]){
        QePidLoopContents(2000,false);
      }else if ((bool)vexRT[Btn7D]){
        QePidLoopContents(2000,true);
      }
    }
  }
}
