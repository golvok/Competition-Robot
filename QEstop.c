#pragma config(Sensor, in1,    AutoPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFrear,              sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl10, clawLimitSensor,     sensorTouch)
#pragma config(Sensor, dgtl11, startButton,         sensorTouch)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           arm2,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "QEstop.c"
AUTHOR: Matthew Walker 

used to hold one or more wheels in place and for stopping exactly when needed.
uses quads and PID to stop in place.
normalStop() is probaly what you want.
As soon as a stop/lock method is called, the QUAD(S) ARE RESET
and the QeStoppingTask tries to keep the locked quad(s) at 0.
*/

#ifndef MAIN_USED
  #define QES_IS_MAIN
  #define MAIN_USED
#endif

#include "controlCode.c"

const int WAIT_AFTER_STOP_TIME = 500;
        //for old chassis \/
float QeStopKp = 2.00;//0.80;//     P tweak
float QeStopKi = 0.00;//0.00;//     I tweak
float QeStopKd = 0.30;//0.30;//     D tweak

/*
globals used to communicate between tasks
they mean what you think they mean
*/
bool lockLeft = false;
bool lockRight = false;

/*
these globals are used as places to save the intergral & old (delta) errors
so that lockwheel can be made more generic and less code copy & pasting
*/
//normally these should be initialized to 0 here, but the ROBOTC compiler doesn't let you and does it for you. (yes that's right)
//also it is done later
OIerrors leftErrors;
OIerrors rightErrors;


/**
resets the left global error saves
*/
void resetLeftOIerrors(){
  leftErrors.oldError = 0;
  leftErrors.integralError = 0;
}


/**
resets the right global error saves
*/
void resetRightOIerrors(){
  rightErrors.oldError = 0;
  rightErrors.integralError = 0;
}
/**
resets both global error saves
*/
void resetOIerrors(){
  resetRightOIerrors();
  resetLeftOIerrors();
}

/**
  rightWheels:
  if true uses right wheels
  if false, left

  please use the a different struct
  for 'errors' per side, and keep using
  the same one for that side throughout
  each continuious usage of this method
*/
void lockWheel(bool rightWheels, OIerrors* errors){
  int change = 0;//the power before possible scaling

  int error = 0;//retrieved error
  int stopPwrQE = 0;//actual motor power

  // get the error
  if(rightWheels){
    error = getQEr();
  }else{
    error = getQEl();
  }

  //adjust the I. error in the passed struct
  errors->integralError += error;

  if (errors->integralError > 200){
    errors->integralError = 200;
  }else if (errors->integralError < -200){
    errors->integralError = -200;
  }
  
  //calc. change using PID
  change = QeStopKp*error + QeStopKi*(errors->integralError) + QeStopKd*(errors->oldError - error);

  //adjust for use as a motor power
  stopPwrQE  = (-change);
  //store the olderrror in the passed struct
  errors->oldError = error;

  //actually set the motors
  if(rightWheels){
    setRight(stopPwrQE);
  }else{
    setLeft(stopPwrQE);
  }
  wait1Msec(50);
}

/**
pass true for the wheels that should be locked
meant to be called as often as possible
(it would be the contents of a loop)
*/
void QeStopPidLoopContents(bool right, bool left){
  if (right){
    lockWheel(RIGHT, rightErrors);
  }
  if (left){
    lockWheel(LEFT, leftErrors);
  }
}

/*
a task that calls QeStopPidLoopContents() in loop
with the globals lockRight & lockLeft as parameters
*/
task QeStoppingTask(){
  while (true){
    QeStopPidLoopContents(lockRight,lockLeft);
  }
}

/*
sets up for & does what it says
*/
void stopLeft(){
  lockLeft = true;
  resetLeftOIerrors();
  resetLeftWheelQE();
  StopTask(QeStoppingTask);
  StartTask(QeStoppingTask);
}
/*
sets up for & does what it says
*/
void releaseLeft(){
  lockLeft = false;
  if (!lockRight) {
    StopTask(QeStoppingTask); 
  }
}
/*
sets up for & does what it says
*/
void stopRight(){
  lockRight = true;
  resetRightOIerrors();
  resetRightWheelQE();
  StopTask(QeStoppingTask);
  StartTask(QeStoppingTask);
}
/*
sets up for & does what it says
*/
void releaseRight(){
  lockRight = false;
  if (!lockLeft) {
    StopTask(QeStoppingTask); 
  }
}
/*
sets up for & does what it says
*/
void stopBothWheels(){
  resetWheelQEs();
  lockLeft = true;
  lockRight = true;
  resetOIerrors();
  StopTask(QeStoppingTask);
  StartTask(QeStoppingTask);
}
/*
sets up for & does what it says
*/
void releaseBothWheels(){
  lockLeft = false;
  lockRight = false;
  StopTask(QeStoppingTask);
}

/*
stops, waits then releases both wheels
*/
void normalStop(){
  stopBothWheels();
  wait1Msec(WAIT_AFTER_STOP_TIME);//woo! momentum and actually having to deal with real life physics!
  releaseBothWheels();
}

#ifdef QES_IS_MAIN
task main(){
#else
void QEstopStraightMain(){
#endif
resetTowerQE();
  resetWheelQEs();

  while(vexRT[Btn5D] != 1){//press Btn5D and exit button to end

    //++++++++++++++ == RC/constant adjusting part == ++++++++++++++

    bool B7UReleased = true;
    bool B7DReleased = true;
    bool B7RReleased = true;
    bool B7LReleased = true;
    bool B8UReleased = true;
    bool B8DReleased = true;

    while(vexRT[Btn6U] != 1){//press Btn6U to get out

      if (vexRT[Btn5D] == 0 && vexRT[Btn6D] == 0){
        setMotorsToRC();
        int errorSample = getRawStraightLineError();
        }else{
        if (vexRT[Btn7U] != 0 && B7UReleased){//if down
          QeStopKp += 0.01;
          //writeDebugStreamLine("QeStopKp = %f", QeStopKp);
          B7UReleased = false;
          } else if (vexRT[Btn7U] != 1){
          B7UReleased = true;
        }
        if (vexRT[Btn7D] != 0 && B7DReleased){//if down
          QeStopKp -= 0.01;
          //writeDebugStreamLine("QeStopKp = %f", QeStopKp);
          B7DReleased = false;
          } else if (vexRT[Btn7D] != 1){
          B7DReleased = true;
        }

        if (vexRT[Btn7R] != 0 && B7RReleased){//if down
          QeStopKd += 0.01;
          //writeDebugStreamLine("QeStopKd = %f", QeStopKd);
          B7RReleased = false;
          } else if (vexRT[Btn7R] != 1){
          B7RReleased = true;
        }
        if (vexRT[Btn7L] != 0 && B7LReleased){//if down
          QeStopKd -= 0.01;
          //writeDebugStreamLine("QeStopKd = %f", QeStopKd);
          B7LReleased = false;
          } else if (vexRT[Btn7L] != 1){
          B7LReleased = true;
        }
        if (vexRT[Btn8U] != 0 && B8UReleased){//if down
          QeStopKi += 0.01;
          //writeDebugStreamLine("QeStopKi = %f", QeStopKi);
          B8UReleased = false;
          } else if (vexRT[Btn8U] != 1){
          B8UReleased = true;
        }
        if (vexRT[Btn8D] != 0 && B8DReleased){//if down
          QeStopKi -= 0.01;
          //writeDebugStreamLine("QeStopKi = %f", QeStopKi);
          B8DReleased = false;
          } else if (vexRT[Btn8D] != 1){
          B8DReleased = true;
        }
      }
    }

    //++++++++++++++ == PID part == ++++++++++++++

    resetWheelQEs();
    resetOIerrors();
    while(vexRT[Btn6D] != 1){//press Btn6D to get out
      if ((bool)vexRT[Btn7R] || (bool)vexRT[Btn7L]){
        QeStopPidLoopContents((bool)vexRT[Btn7R],(bool)vexRT[Btn7L]);
      }else{
        QeStopPidLoopContents(true,true);
      }
    }
    wait1Msec(WAIT_AFTER_STOP_TIME);
  }
}
