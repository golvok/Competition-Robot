#pragma config(Sensor, in1,    AutoPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFrear,              sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl10, clawLimitSensor,     sensorTouch)
#pragma config(Sensor, dgtl11, startButton,         sensorTouch)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           arm2,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "examRC.c"
AUTHOR: Matthew Walker 

The user control code that was used at the second competition
and for my exam. Lots of automation, highest level of abstraction,
many useful things for navagating the gateway arena.

Controls:
  setDriveMotorsToRC() controls, plus:
  grabAndLiftAfterTouch controls
  "stopper" controls -- see controlCode.c
  7U - straight line forward
  7D - straight line backward
  7R - 90deg right turn
  7L - 90deg left turn  
  8U - see examRCmain()
*/

#ifndef MAIN_USED
#define EXRC_IS_MAIN
#define MAIN_USED
#endif

#include "controlCode.c"
#include "QEstraightLine.c"
#include "QEturning.c"
#include "LFstraightLine.c"
#include "LFturning.c"
#include "QEstop.c"
#include "armPID.c"
#include "grabAndLiftAfterTouch.c"

#ifdef EXRC_IS_MAIN
task main(){
#else
examRCmain(){
#endif
    static int B7UReleased = true;
    static int B7DReleased = true;

    StartTask(stopper);// stopper is defined in controlCode.c
    while(true){
      setDriveMotorsToRC();
      grabAndLiftAfterTouchLoopContents(false,false,false);

      //I'd have "VEX Gateway - Field Specs.20110829.pdf", page #4 & #5, handy for this part.
      //These are more useful for the driver's skills 
      //challlenge (which was my exam) than anything else
      if (vexRT[Btn8U]){
        if (vexRT[Ch4]>100){//left analog stick - horizontal - all the way right
          //you know how the tape on the field in shaped like a tick-tack-toe board(#)?,
          //this will travel in a straight line the distance between two "intersections"
          //of tape and then turn in 90deg right.
          goForwardUntilLine(165*TICKS_CM,DO_STOP,stopNow);// "what is this 'stopNow'?" you ask.
                                                           // see the "stopper" task in controlCode.c
          turn90(RIGHT, DO_STOP, stopNow);
        }else if (vexRT[Ch4]<-100){// all the way left
          // similar to the first conditon's behavior, except left.
          goForwardUntilLine(165*TICKS_CM, DO_STOP, stopNow);
          turn90(LEFT, DO_STOP, stopNow);
        }else{// in the middle somewhere
          //if you execute this code wile at a tape intersection that is in the interaction
          //zone, pointing in at the oter intersection in th zone, the bot will drive straight
          //and stop in front of the 30 inch goal. Or if you are holding 8U still, continue on
          //to the opposite 11.5 inch goal.
          goForwardUntilLine(73*TICKS_CM, DONT_STOP, stopNow);
          if (vexRT[Btn8U]){//if 8U in down still, or again, as the previous part finishes
            goForwardUntilLine(97*TICKS_CM, DONT_STOP, stopNow);
          }
          normalStop();
        }
      }
      
      
      //to go straight forward
      if (vexRT[Btn7U]){
        if (B7UReleased) {
          //resets as you press it but not again until you release it
          resetWheelQEs();
        }
        B7UReleased = false;
        QePidLoopContents(10000,FORWARD);//ridulously high number
      }else if (!B7UReleased) {
        B7UReleased = true;
      }
      //to go straight backward
      if (vexRT[Btn7D]){
        if (B7DReleased) {
          //resets as you press it but not again until you release it
          resetWheelQEs();
        }
        B7DReleased = false;
        QePidLoopContents(10000,BACKWARD);//ridulously high number
      }else if (!B7DReleased) {
        B7DReleased = true;
      }
      //turn 90deg right
      if(vexRT[Btn7R]){
        turn90(RIGHT,DO_STOP,stopNow);
      }
      //turn 90deg left
      if(vexRT[Btn7L]){
        turn90(LEFT,DO_STOP,stopNow);
      }
    }
  }
