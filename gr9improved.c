#pragma config(Sensor, in1,    pgrmSelect1,         sensorPotentiometer)
#pragma config(Sensor, in3,    LFfront,             sensorLineFollower)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFcentre,            sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, dgtl1,  QCright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  QCleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  FSONAR,              sensorSONAR_cm)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "gr9improved.c"
AUTHOR: Matthew Walker 

An experemental control scheme that failed to be usable.
see what happens when the stick is:
  all the way right, left, up, and down.
  in the top-left, top-right, bottom-left, and bottom-right corners(?)

Controls:
  the right analog stick.
*/

void setRight(float rPwr){
  motor[rightFront] = rPwr;
  motor[rightRear] = rPwr;
}

void setLeft(float lPwr){
  motor[leftFront] = lPwr;
  motor[leftRear] = lPwr;
}

float min(float f1,float f2){
  if (f1 < f2){
    return f1;
    }else{
    return f2;
  }
}

void setMotors(int chan1, int chan2){
  float power;
  float angle;
  power = (min(sqrt((chan1 * chan1) + (chan2 * chan2)),127));
  angle = (radiansToDegrees(atan(chan2 / chan1)));
  if (chan2 == 0) {
    setLeft(0);
    setRight(0);
  } else {
    if (chan1 > 0) {
      if (chan2 > 0) {
        setLeft(power * (min(angle + 45, 90) / 90));
        setRight(power * ((angle) / 90));
      } else {
        setLeft(power * ((-angle) / 90));
        setRight(power * (min(-angle + 45, 90) / 90));
      }
    } else if (chan1 < 0) {
      if (chan2 > 0) {
        setLeft(-(power * (min(-angle + 45, 90) / 90)));
        setRight(-(power * ((-angle) / 90)));
      } else {
        setLeft(-(power * ((angle) / 90)));
        setRight(-(power * (min(angle + 45, 90) / 90)));
      }
    } else {
      setLeft(chan2);
      setRight(chan2);
    }
  }
}

task main() {
  while(vexRT[Btn6D] != 1){//press Btn6D to get out
    setMotors(vexRT[Ch1], vexRT[Ch2]);
  }
}
