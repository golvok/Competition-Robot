#pragma config(Sensor, in1,    AutoPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFrear,              sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl10, clawLimitSensor,     sensorTouch)
#pragma config(Sensor, dgtl11, startButton,         sensorTouch)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           arm2,          tmotorNormal, openLoop)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "autonomous.c"
AUTHOR: Matthew Walker 

Selects and executes an autonomous program
based on the value of 'pgrmSelect()' in 'controlCode.c'

*/

#ifndef MAIN_USED
  #define AUT_IS_MAIN
  #define MAIN_USED
#endif


#include "controlCode.c"
#include "QEstraightLine.c"
#include "QEturning.c"
#include "LFstraightLine.c"
#include "LFturning.c"
#include "QEstop.c"
#include "armPID.c"
#include "grabAndLiftAfterTouch.c"


#ifdef AUT_IS_MAIN
task main(){
  while (!(bool)vexRT[Btn7U]){
    setMotorsToRC();
    int pgrmNum = pgrmSelect();
  }
#else
void autonomousCode(){
#endif
  //while (true){
    /*
    for PROGRAMMING SKILLS -- RED ISOLATION ZONE
    position pointing at tower near start at 45 degree angle
    with enough room to lift claw and preloads. Put a barrel
    on a ball in the claw.
    */
    if (pgrmSelect() == 1){
      /*grabObject();
      liftArmTo(highTowerArmAngleIndex);//doesn't block
      raiseTower(true);//blocks, takes longer (confirmed,barely)
      goForwardCm(15);
      releaseObject();
      for(int i=0 ; i<3 ; i++){//3 times
        while(!getClawLimit() && !getStartButton()){}//wait until an object
        grabObject();
        releaseObject();
      }*/
    }
    /*
    for TESTING
    */
    if (pgrmSelect() == 2){
      for (int i = 0;i<4;i++){
        goForwardCm(70);
        stopBothWheels();
        wait1Msec(2000);
        releaseBothWheels();
        turn90(RIGHT,DONT_STOP);
      }
      normalStop();
      /*
      goForwardUntilLine(177*TICKS_CM);
      turnAtLine(true);
      goForwardCm(50);
      */
    }
    /*
    for AUTONOMOUS PART OF MATCH -- BLUE ISOLATION ZONE
	    Move forward 15cm
	    Drop (high)
	    Re adjust to straight forward (press button when done)
			Forward until line
			turn right on line
			foreward 120 (non blocking)
			(pick up middle cylinder while moving)
			continue foreward 120
			Drop (low)
			Back up 10cm
			Turn 90o right
			Forward 30cm
			(pick up sphere)
			Drop (medium)
			Turn 60o left
			Go forward 20cm
			180o turn
			Forward 20cm
			Drop (medium)
    */
    if (pgrmSelect() == 3){
      grabObject();
      liftArmTo(highTowerArmAngleIndex);//doesn't block
      raiseTower(true);//blocks, takes longer
      wait1Msec(1000);
      goForwardCm(15);
      releaseObject();
      //goBackwardCm(15);
      setRight(-127);
      setLeft(-127);
      wait1Msec(1000);
      setRight(0);
      setLeft(0);
      while (!getStartButton()){}//press button when done realigning
      goForwardUntilLine(25,DONT_STOP);
      turnUntilLine(LEFT,DO_STOP);
      while(!getClawLimit()){
        QePidLoopContents(120,false);
      }
      grabObject();
      liftArmTo(lowTowerArmAngleIndex);
      goForwardCm(85);
      wait1Msec(100);
      releaseObject();
      setLeft(-127);
      setRight(-127);
      wait1Msec(500);
      setLeft(0);
      setRight(0);
      turnDegrees(180,RIGHT,false);
      goForwardCm(90);
      turn90(RIGHT,true);

    }
    /*
    for INTERACTION ZONE
    point at pile of objects
    just drives foreward 1m
    */
    if (pgrmSelect() == 4){
      goForwardCm(100);
      turn90(RIGHT,DONT_STOP);
      turn90(RIGHT,DONT_STOP);
      goForwardCm(100);
      while (!getStartButton()){}

    }

    /*
    for RED ISOLATION ZONE
    similar to blue's
    */
    if (pgrmSelect() == 5){

      grabObject();
      liftArmTo(highTowerArmAngleIndex);//doesn't block
      raiseTower(true);//blocks, takes longer
      wait1Msec(1000);
      goForwardCm(15);
      releaseObject();
      //goBackwardCm(15);
      setRight(-127);
      setLeft(-127);
      wait1Msec(1000);
      setRight(0);
      setLeft(0);

      while (!getStartButton()){}//press button when done realigning
      goForwardUntilLine(25,DONT_STOP);
      turnUntilLine(RIGHT,true);
      while(getWheelQeAverage()<60*TICKS_CM){
        QePidLoopContents(120,false);
      }
      grabObject();
      liftArmTo(lowTowerArmAngleIndex);
      goForwardCm(85);
      wait1Msec(100);
      releaseObject();
      setLeft(-127);
      setRight(-127);
      wait1Msec(500);
      setLeft(0);
      setRight(0);
      turnDegrees(180,RIGHT,DONT_STOP);
      goForwardCm(90);
      turn90(Right,DO_STOP);
    }
  //}
}
