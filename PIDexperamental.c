#pragma config(Sensor, in1,    pgrmSelect1,         sensorPotentiometer)
#pragma config(Sensor, in3,    LFfront,             sensorLineFollower)
#pragma config(Sensor, in4,    LFright,             sensorLineFollower)
#pragma config(Sensor, in5,    LFcentre,            sensorLineFollower)
#pragma config(Sensor, in6,    LFleft,              sensorLineFollower)
#pragma config(Sensor, in7,    armAngle,            sensorPotentiometer)
#pragma config(Sensor, dgtl3,  SOLclaw,             sensorDigitalOut)
#pragma config(Sensor, dgtl1,  QEtower,             sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  QEleft,              sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  QEright,             sensorQuadEncoder)
#pragma config(Sensor, dgtl11, FSONAR,              sensorSONAR_cm)
#pragma config(Motor,  port1,           leftRear,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           arm,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           tower1,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           tower2,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorNormal, openLoop)
#pragma config(Motor,  port9,           rightRear,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftFront,     tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**  *****FILE COMMENT*****
FOR: "PIDexperamental.c"
AUTHOR: Matthew Walker 

first attempt at PID possibly.

*/

#include "controlCode.c"

task main(){
  resetTowerQE();
  resetWheelQEs();
  float Kp = 1.25;//     P tweak anything higer than this will work
  float Ki = 0.05;//     I tweak
  float Kd = 0.40;//     D tweak

  while(vexRT[Btn5D] != 1){//press Btn5D and exit button to end

    //++++++++++++++ == RC/adjusting part == ++++++++++++++

    bool B7UReleased = true;
    bool B7DReleased = true;
    bool B7RReleased = true;
    bool B7LReleased = true;
    bool B8UReleased = true;
    bool B8DReleased = true;

    while(vexRT[Btn6U] != 1){//press Btn6U to get out
      setMotorsToRC();
      if (vexRT[Btn7U] != 0 && B7UReleased){//if down
        Kp += 0.01;
        //writeDebugStreamLine("Kp = %f", Kp);
        B7UReleased = false;
        } else if (vexRT[Btn7U] != 1){
        B7UReleased = true;
      }
      if (vexRT[Btn7D] != 0 && B7DReleased){//if down
        Kp -= 0.01;
        //writeDebugStreamLine("Kp = %f", Kp);
        B7DReleased = false;
        } else if (vexRT[Btn7D] != 1){
        B7DReleased = true;
      }

      if (vexRT[Btn7R] != 0 && B7RReleased){//if down
        Kd += 0.01;
        //writeDebugStreamLine("Kd = %f", Kd);
        B7RReleased = false;
        } else if (vexRT[Btn7R] != 1){
        B7RReleased = true;
      }
      if (vexRT[Btn7L] != 0 && B7LReleased){//if down
        Kd -= 0.01;
        writeDebugStreamLine("Kd = %f", Kd);
        B7LReleased = false;
        } else if (vexRT[Btn7L] != 1){
        B7LReleased = true;
      }
      if (vexRT[Btn8U] != 0 && B8UReleased){//if down
        Ki += 0.01;
        //writeDebugStreamLine("Ki = %f", Ki);
        B8UReleased = false;
        } else if (vexRT[Btn8U] != 1){
        B8UReleased = true;
      }
      if (vexRT[Btn8D] != 0&& B8DReleased){//if down
        Ki -= 0.01;
        //writeDebugStreamLine("Ki = %f", Ki);
        B8DReleased = false;
        } else if (vexRT[Btn8D] != 1){
        B8DReleased = true;
      }
    }

    //++++++++++++++ == PID part == ++++++++++++++

    float rightPwr = 0;
    float leftPwr = 0;
    int integralErr = 0;
    int change = 0;
    int oldError = 0;
    int error = 0;
    resetWheelQEs();
    while(vexRT[Btn6D] != 1){//press Btn6D to get out
      wait1Msec(50);
      error = getRawStraightLineError();
      integralErr += error;
      if (integralErr > 200){
        integralErr = 200;
      }else if (integralErr < -200){
        integralErr = -200;
      }
      change = Kp*error + Ki*integralErr + Kd*(oldError - error);
      rightPwr = -change+96;
      leftPwr = change+96;
      oldError = error;
      while (vexRT[Btn5U] != 0){//hold 5U to pause
        setRight(0);
        setLeft(0);
      }
      setRight(rightPwr);
      setLeft(leftPwr);
    }
  }
}
